{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/srijanpatel/Documents/vyne-ai/app/api/deploy/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\n\ninterface CloudflareResponse {\n  success: boolean;\n  result?: {\n    id?: string;\n    url?: string;\n    environment?: string;\n    deployment_trigger?: {\n      metadata?: {\n        branch?: string;\n        commit_hash?: string;\n      };\n    };\n    stages?: Array<{\n      name?: string;\n      status?: string;\n    }>;\n    latest_stage?: {\n      name?: string;\n      status?: string;\n    };\n  };\n  errors?: Array<{ code: number; message: string }>;\n  messages?: Array<any>;\n}\n\ninterface PagesDeploymentStatus {\n  result?: {\n    latest_stage?: {\n      name?: string;\n      status?: string;\n      started_on?: string | null;\n      ended_on?: string | null;\n    };\n  };\n}\n\n\n\nexport async function POST(req: Request) {\n  try {\n    // Validate environment variables\n    const CF_ACCOUNT_ID = process.env.CF_ACCOUNT_ID;\n    const CF_PROJECT = process.env.CF_PROJECT;\n    const CF_API_TOKEN = process.env.CF_API_TOKEN;\n\n    if (!CF_ACCOUNT_ID || !CF_PROJECT || !CF_API_TOKEN) {\n      console.error(\"Missing Cloudflare env vars\");\n      return NextResponse.json(\n        { success: false, error: \"Missing Cloudflare configuration\" },\n        { status: 500 }\n      );\n    }\n\n    // Get the FormData from the request\n    const incoming = await req.formData();\n\n    // Rebuild FormData to ensure file blobs are real Blobs (some runtimes' FormData\n    // implementations are not directly forwardable). Also collect diagnostics.\n    const forwardForm = new FormData();\n    const debugEntries: Array<{ key: string; type: string; size?: number }> = [];\n\n    const isFileLike = (value: FormDataEntryValue): value is File =>\n      typeof value === \"object\" && value !== null && typeof (value as File).arrayBuffer === \"function\";\n\n    for (const [key, value] of incoming.entries()) {\n      try {\n        // If value looks like a File (has arrayBuffer), convert to Blob\n        if (isFileLike(value)) {\n          const buf = await value.arrayBuffer();\n          const u8 = new Uint8Array(buf);\n          const blob = new Blob([u8], { type: value.type || \"application/octet-stream\" });\n          // use the original filename if provided\n          const filename = value.name || key;\n          forwardForm.append(key, blob, filename);\n          debugEntries.push({ key, type: \"file\", size: u8.byteLength });\n        } else {\n          forwardForm.append(key, String(value));\n          debugEntries.push({ key, type: typeof value });\n        }\n      } catch (e) {\n        console.warn(\"Failed to convert form entry\", key, e);\n        // fallback: append stringified value\n        forwardForm.append(key, String(value));\n        debugEntries.push({ key, type: typeof value });\n      }\n    }\n\n    console.log(\"üì§ Forwarding FormData entries to Cloudflare:\", debugEntries);\n\n    // Forward the reconstructed FormData to Cloudflare Pages API\n    const cfUrl = `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/pages/projects/${CF_PROJECT}/deployments`;\n    const cfRes = await fetch(cfUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${CF_API_TOKEN}`,\n      },\n      body: forwardForm,\n    });\n\n    const text = await cfRes.text();\n    let data: CloudflareResponse | null = null;\n    \n    try {\n      data = JSON.parse(text);\n    } catch (err) {\n      console.error(\"Cloudflare returned non-JSON:\", cfRes.status, text.slice(0, 500), err);\n      return NextResponse.json(\n        {\n          success: false,\n          error: `Cloudflare returned non-JSON response (status ${cfRes.status})`,\n          details: text.slice(0, 500),\n        },\n        { status: 502 }\n      );\n    }\n\n    if (!cfRes.ok || !data?.success) {\n      console.error(\"Cloudflare deploy failed:\", cfRes.status, data);\n      return NextResponse.json(\n        {\n          success: false,\n          error: `Cloudflare deploy failed (status ${cfRes.status})`,\n          details: data,\n        },\n        { status: cfRes.status >= 400 ? cfRes.status : 502 }\n      );\n    }\n\n    // Log the full response to see what Cloudflare returns\n    console.log(\"üì¶ Cloudflare deployment response:\", JSON.stringify(data, null, 2));\n\n    // After creating the deployment, poll Cloudflare for the deployment stage\n    // until it becomes 'completed' or 'failed' (or we timeout). This helps\n    // avoid returning a success to the client while Pages hasn't processed\n    // the uploaded files yet.\n    const deploymentId = data.result?.id;\n    async function pollDeployment(id: string, timeoutMs = 60_000): Promise<PagesDeploymentStatus | null> {\n      const start = Date.now();\n      const url = `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/pages/projects/${CF_PROJECT}/deployments/${id}`;\n      while (Date.now() - start < timeoutMs) {\n        try {\n          const statusRes = await fetch(url, {\n            headers: { Authorization: `Bearer ${CF_API_TOKEN}` },\n          });\n          const statusJson: PagesDeploymentStatus = await statusRes.json();\n          const stage = statusJson?.result?.latest_stage;\n          console.log(\"üîÅ Poll deployment status:\", stage);\n          // Treat Cloudflare stage.status 'success' as a completed stage as well.\n          if (stage && (stage.status === \"completed\" || stage.status === \"published\" || stage.status === \"success\")) {\n            return statusJson;\n          }\n          if (stage && stage.status === \"failed\") {\n            return statusJson; // caller will inspect and throw\n          }\n        } catch (e) {\n          console.warn(\"Poll error\", e);\n        }\n        // wait 2s then retry\n        await new Promise((r) => setTimeout(r, 2000));\n      }\n      return null; // timed out\n    }\n\n    let finalStatus: PagesDeploymentStatus | null = null;\n    if (deploymentId) {\n      finalStatus = await pollDeployment(deploymentId, 90_000);\n      console.log(\"üîö Final deployment poll result:\", finalStatus?.result?.latest_stage);\n    }\n\n    // Try different URL formats that Cloudflare might return\n    let deploymentUrl = data.result?.url;\n    \n    // If no URL in result, construct the production URL manually\n    if (!deploymentUrl) {\n      // Cloudflare Pages production URL format: https://<project-name>.pages.dev\n      deploymentUrl = `https://${CF_PROJECT}.pages.dev`;\n      console.log(\"‚ö†Ô∏è No URL in response, using production URL:\", deploymentUrl);\n    }\n\n    const finalStage = finalStatus?.result?.latest_stage ?? data.result?.latest_stage;\n\n    // Also log the deployment ID for reference\n    console.log(\"‚úÖ Deployment ID:\", deploymentId);\n    console.log(\"‚úÖ Deployment URL:\", deploymentUrl);\n    console.log(\"‚úÖ Environment:\", data.result?.environment);\n    console.log(\"‚úÖ Latest stage:\", finalStage);\n\n    // Optionally, attempt to hit the deployment URL once we believe it is live.\n    let siteStatus: { ok: boolean; status: number | null } | null = null;\n    if (deploymentUrl) {\n      try {\n        const siteResponse = await fetch(deploymentUrl, { method: \"HEAD\" });\n        siteStatus = { ok: siteResponse.ok, status: siteResponse.status };\n      } catch (siteError) {\n        console.warn(\"Failed to HEAD deployment URL\", siteError);\n        siteStatus = { ok: false, status: null };\n      }\n    }\n\n    return NextResponse.json({\n      success: true,\n      url: deploymentUrl,\n      deploymentId: deploymentId,\n      environment: data.result?.environment,\n      fullResponse: data.result, // Include full response for debugging\n      latestStage: finalStage ?? null,\n      siteStatus,\n    });\n  } catch (err: unknown) {\n    console.error(\"Deployment error:\", err);\n    return NextResponse.json(\n      {\n        success: false,\n        error: err instanceof Error ? err.message : \"Unknown error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n\n\n\n"],"names":[],"mappings":";;;;AAAA;;AAwCO,eAAe,KAAK,GAAY;IACrC,IAAI;QACF,iCAAiC;QACjC,MAAM,gBAAgB,QAAQ,GAAG,CAAC,aAAa;QAC/C,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU;QACzC,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY;QAE7C,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,cAAc;YAClD,QAAQ,KAAK,CAAC;YACd,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAmC,GAC5D;gBAAE,QAAQ;YAAI;QAElB;QAEA,oCAAoC;QACpC,MAAM,WAAW,MAAM,IAAI,QAAQ;QAEnC,gFAAgF;QAChF,2EAA2E;QAC3E,MAAM,cAAc,IAAI;QACxB,MAAM,eAAoE,EAAE;QAE5E,MAAM,aAAa,CAAC,QAClB,OAAO,UAAU,YAAY,UAAU,QAAQ,OAAO,AAAC,MAAe,WAAW,KAAK;QAExF,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,SAAS,OAAO,GAAI;YAC7C,IAAI;gBACF,gEAAgE;gBAChE,IAAI,WAAW,QAAQ;oBACrB,MAAM,MAAM,MAAM,MAAM,WAAW;oBACnC,MAAM,KAAK,IAAI,WAAW;oBAC1B,MAAM,OAAO,IAAI,KAAK;wBAAC;qBAAG,EAAE;wBAAE,MAAM,MAAM,IAAI,IAAI;oBAA2B;oBAC7E,wCAAwC;oBACxC,MAAM,WAAW,MAAM,IAAI,IAAI;oBAC/B,YAAY,MAAM,CAAC,KAAK,MAAM;oBAC9B,aAAa,IAAI,CAAC;wBAAE;wBAAK,MAAM;wBAAQ,MAAM,GAAG,UAAU;oBAAC;gBAC7D,OAAO;oBACL,YAAY,MAAM,CAAC,KAAK,OAAO;oBAC/B,aAAa,IAAI,CAAC;wBAAE;wBAAK,MAAM,OAAO;oBAAM;gBAC9C;YACF,EAAE,OAAO,GAAG;gBACV,QAAQ,IAAI,CAAC,gCAAgC,KAAK;gBAClD,qCAAqC;gBACrC,YAAY,MAAM,CAAC,KAAK,OAAO;gBAC/B,aAAa,IAAI,CAAC;oBAAE;oBAAK,MAAM,OAAO;gBAAM;YAC9C;QACF;QAEA,QAAQ,GAAG,CAAC,iDAAiD;QAE7D,6DAA6D;QAC7D,MAAM,QAAQ,CAAC,8CAA8C,EAAE,cAAc,gBAAgB,EAAE,WAAW,YAAY,CAAC;QACvH,MAAM,QAAQ,MAAM,MAAM,OAAO;YAC/B,QAAQ;YACR,SAAS;gBACP,eAAe,CAAC,OAAO,EAAE,cAAc;YACzC;YACA,MAAM;QACR;QAEA,MAAM,OAAO,MAAM,MAAM,IAAI;QAC7B,IAAI,OAAkC;QAEtC,IAAI;YACF,OAAO,KAAK,KAAK,CAAC;QACpB,EAAE,OAAO,KAAK;YACZ,QAAQ,KAAK,CAAC,iCAAiC,MAAM,MAAM,EAAE,KAAK,KAAK,CAAC,GAAG,MAAM;YACjF,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,CAAC,8CAA8C,EAAE,MAAM,MAAM,CAAC,CAAC,CAAC;gBACvE,SAAS,KAAK,KAAK,CAAC,GAAG;YACzB,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,SAAS;YAC/B,QAAQ,KAAK,CAAC,6BAA6B,MAAM,MAAM,EAAE;YACzD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO,CAAC,iCAAiC,EAAE,MAAM,MAAM,CAAC,CAAC,CAAC;gBAC1D,SAAS;YACX,GACA;gBAAE,QAAQ,MAAM,MAAM,IAAI,MAAM,MAAM,MAAM,GAAG;YAAI;QAEvD;QAEA,uDAAuD;QACvD,QAAQ,GAAG,CAAC,sCAAsC,KAAK,SAAS,CAAC,MAAM,MAAM;QAE7E,0EAA0E;QAC1E,uEAAuE;QACvE,uEAAuE;QACvE,0BAA0B;QAC1B,MAAM,eAAe,KAAK,MAAM,EAAE;QAClC,eAAe,eAAe,EAAU,EAAE,YAAY,MAAM;YAC1D,MAAM,QAAQ,KAAK,GAAG;YACtB,MAAM,MAAM,CAAC,8CAA8C,EAAE,cAAc,gBAAgB,EAAE,WAAW,aAAa,EAAE,IAAI;YAC3H,MAAO,KAAK,GAAG,KAAK,QAAQ,UAAW;gBACrC,IAAI;oBACF,MAAM,YAAY,MAAM,MAAM,KAAK;wBACjC,SAAS;4BAAE,eAAe,CAAC,OAAO,EAAE,cAAc;wBAAC;oBACrD;oBACA,MAAM,aAAoC,MAAM,UAAU,IAAI;oBAC9D,MAAM,QAAQ,YAAY,QAAQ;oBAClC,QAAQ,GAAG,CAAC,8BAA8B;oBAC1C,wEAAwE;oBACxE,IAAI,SAAS,CAAC,MAAM,MAAM,KAAK,eAAe,MAAM,MAAM,KAAK,eAAe,MAAM,MAAM,KAAK,SAAS,GAAG;wBACzG,OAAO;oBACT;oBACA,IAAI,SAAS,MAAM,MAAM,KAAK,UAAU;wBACtC,OAAO,YAAY,gCAAgC;oBACrD;gBACF,EAAE,OAAO,GAAG;oBACV,QAAQ,IAAI,CAAC,cAAc;gBAC7B;gBACA,qBAAqB;gBACrB,MAAM,IAAI,QAAQ,CAAC,IAAM,WAAW,GAAG;YACzC;YACA,OAAO,MAAM,YAAY;QAC3B;QAEA,IAAI,cAA4C;QAChD,IAAI,cAAc;YAChB,cAAc,MAAM,eAAe,cAAc;YACjD,QAAQ,GAAG,CAAC,oCAAoC,aAAa,QAAQ;QACvE;QAEA,yDAAyD;QACzD,IAAI,gBAAgB,KAAK,MAAM,EAAE;QAEjC,6DAA6D;QAC7D,IAAI,CAAC,eAAe;YAClB,2EAA2E;YAC3E,gBAAgB,CAAC,QAAQ,EAAE,WAAW,UAAU,CAAC;YACjD,QAAQ,GAAG,CAAC,gDAAgD;QAC9D;QAEA,MAAM,aAAa,aAAa,QAAQ,gBAAgB,KAAK,MAAM,EAAE;QAErE,2CAA2C;QAC3C,QAAQ,GAAG,CAAC,oBAAoB;QAChC,QAAQ,GAAG,CAAC,qBAAqB;QACjC,QAAQ,GAAG,CAAC,kBAAkB,KAAK,MAAM,EAAE;QAC3C,QAAQ,GAAG,CAAC,mBAAmB;QAE/B,4EAA4E;QAC5E,IAAI,aAA4D;QAChE,IAAI,eAAe;YACjB,IAAI;gBACF,MAAM,eAAe,MAAM,MAAM,eAAe;oBAAE,QAAQ;gBAAO;gBACjE,aAAa;oBAAE,IAAI,aAAa,EAAE;oBAAE,QAAQ,aAAa,MAAM;gBAAC;YAClE,EAAE,OAAO,WAAW;gBAClB,QAAQ,IAAI,CAAC,iCAAiC;gBAC9C,aAAa;oBAAE,IAAI;oBAAO,QAAQ;gBAAK;YACzC;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,KAAK;YACL,cAAc;YACd,aAAa,KAAK,MAAM,EAAE;YAC1B,cAAc,KAAK,MAAM;YACzB,aAAa,cAAc;YAC3B;QACF;IACF,EAAE,OAAO,KAAc;QACrB,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO,eAAe,QAAQ,IAAI,OAAO,GAAG;QAC9C,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}